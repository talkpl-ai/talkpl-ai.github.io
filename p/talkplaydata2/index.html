<!DOCTYPE html>
<html lang="en">

<head>
    <title>TalkPlayData 2 - Raw JSON Data</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        .site-header {
            position: sticky;
            top: 0;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: saturate(180%) blur(10px);
            border-bottom: 1px solid var(--border);
        }

        .site-header .container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo {
            font-weight: 700;
            letter-spacing: 0.4px;
            font-size: 22px;
            color: var(--text);
        }

        .logo-img {
            height: auto;
            width: 100px;
            display: block;
        }

        @media (min-width: 900px) {
            .logo-img {
                max-height: 28px;
            }
        }

        .tagline {
            color: var(--muted);
            font-size: 12px;
        }

        .top-nav a {
            color: var(--brand);
            font-weight: 400;
            padding: 8px 12px;
        }

        .top-nav a:hover {
            background: #f2f2f2;
            text-decoration: none;
        }

        .top-nav a+a {
            margin-left: 8px;
        }

        .nav-bar {
            background-color: white;
            padding: 0.5rem 1rem;
            position: fixed;
            top: 0;
            width: 100%;
            z-index: 1000;
            border-bottom: 1px solid #eee;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.02);
        }

        .nav-bar a {
            color: #444;
            text-decoration: none;
            padding: 0.3rem 0.8rem;
            margin: 0 0.3rem;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.95rem;
        }

        .nav-bar a:hover {
            background-color: #f5f5f5;
            color: #000;
        }

        .nav-bar a.active {
            background-color: #f5f5f5;
            color: #000;
        }

        .content {
            margin-top: 50px;
            padding: 20px;
        }

        .data-browser {
            max-width: 1200px;
            margin: 0 auto;
        }

        .user-session {
            margin-bottom: 2rem;
            padding: 1rem;
            border: 1px solid #eee;
            border-radius: 4px;
            background-color: #f9f9f9;
        }

        .json-files {
            display: grid;
            gap: 1rem;
            margin-top: 1rem;
        }

        .file-item {
            padding: 1rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: white;
        }

        .file-item h4 {
            margin: 0 0 0.5rem 0;
        }

        .file-item h4 a {
            color: #007bff;
            text-decoration: none;
        }

        .file-item h4 a:hover {
            text-decoration: underline;
        }

        .main-file {
            border: 2px solid #007bff;
            background-color: #f8f9ff;
        }

        .main-file h4 a {
            color: #007bff;
            font-weight: 600;
        }

        .secondary-files-container {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .secondary-file {
            border: 1px solid #ddd;
            background-color: #fafafa;
            opacity: 0.8;
            flex: 1;
            padding: 0.5rem;
            text-align: center;
        }

        .secondary-file h4 {
            font-size: 0.8rem;
            margin: 0 0 0.25rem 0;
        }

        .secondary-file h4 a {
            color: #4a90e2;
            font-weight: 400;
        }

        .secondary-file p {
            font-size: 0.7rem;
            color: #888;
            margin: 0;
        }

        .json-header {
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #eee;
        }

        .json-display {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 1rem;
            overflow-x: auto;
            font-size: 0.9rem;
            line-height: 1.4;
            max-height: 600px;
            overflow-y: auto;
        }

        .json-controls {
            margin-bottom: 1rem;
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .json-controls button {
            padding: 0.5rem 1rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: white;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .json-controls button:hover {
            background-color: #f5f5f5;
        }

        .json-controls button.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }

        .collapsible {
            cursor: pointer;
        }

        .collapsible:hover {
            background-color: #e9ecef;
        }

        .collapsible-content {
            display: none;
            padding-left: 2rem;
        }

        .collapsible-content.expanded {
            display: block;
        }

        .toggle-icon {
            display: inline-block;
            width: 1rem;
            text-align: center;
            margin-right: 0.5rem;
            font-weight: bold;
        }

        .json-key {
            color: #0066cc;
            font-weight: 500;
        }

        .json-value {
            color: #333;
        }

        .json-info {
            color: #666;
            font-size: 0.8em;
            margin-left: 0.5rem;
        }

        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            padding: 0.5rem 1rem;
            color: #444;
            text-decoration: none;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f8f9fa;
            transition: all 0.2s ease;
        }

        .back-link:hover {
            color: #000;
            background-color: #e9ecef;
            border-color: #adb5bd;
            text-decoration: none;
        }

        .loading {
            text-align: center;
            padding: 2rem;
            color: #666;
        }

        .error {
            color: #dc3545;
            padding: 1rem;
            border: 1px solid #dc3545;
            border-radius: 4px;
            background-color: #f8d7da;
        }
    </style>
</head>

<body>
    <header class="site-header">
        <div class="container">
            <div class="brand">
                <a href="https://talkpl.ai">
                    <img src="https://talkpl.ai/static/images/logo.svg" alt="talkplay logo" class="logo-img">
                </a>
            </div>
        </div>
    </header>

    <div class="content">
        <div class="container pt-5 shadow p-5 mb-5 bg-white rounded">
            <h2>TalkPlayData 2</h2>
            
            <div class="alert alert-info" role="alert">
                <div class="mt-3">
                    <ul class="mb-0" style="list-style: none; padding-left: 0;">
                        <li>ðŸ“„ <strong>Paper:</strong> <a href="https://arxiv.org/abs/2509.09685" target="_blank"> On arXiv: "TalkPlayData 2: An Agentic Synthetic Data
                            Pipeline for Multimodal Conversational Music Recommendation"</a></li>
                        <li>ðŸ“Š <strong>Dataset:</strong> <a
                                href="https://huggingface.co/datasets/talkpl-ai/TalkPlayData-2" target="_blank">Hugging
                                Face. 16,500 conversations in total. 15,500 in training split and 1,000 in test split.</a></li>
                        <li>ðŸ’» <strong>Generation Code:</strong> <a href="https://github.com/talkpl-ai/talkplaydata-2"
                                target="_blank">GitHub</a>
                            â€” self-contained and runnable with a small dummy set, designed to expose the
                            exact prompts and the end-to-end process.</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container pt-5 shadow p-5 mb-5 bg-white rounded">
            <div class="mb-4">
                <h3>What is TalkPlayData 2?</h3>
                <p>We generate <strong>realistic</strong> conversation data for music recommendation research that
                    covers <strong>various conversation scenarios</strong> and involves <strong>multimodal</strong>
                    aspects of music.</p>
                <p>We achieve it by letting two LLMs talk to each other about music, since LLMs can definitely talk to
                    each other coherently and naturally. But we need grounding music data to make the conversation
                    realistic and relevant to real music items we have. So, we use a listening session dataset to
                    condition the conversation, where each session's tracks become the recommendation pool of the
                    resulting conversation.</p>

                <p>But that's not enough. We also condition the Listener LLM with a conversation goal, which is
                    finetuned based on the recommendation pool, by the Goal LLM. And - to do it better, we also
                    condition the Listener LLM with a Listener Profile, which is based on basic demography and inferred
                    information of the listener.</p>

                <p>Information Imbalance is an important aspect of TalkPlayData 2. This Listener Profile is shared with
                    the Goal LLM, Listener LLM, and the Recsys LLM. However, the conversation goal is shared only with
                    the Listener LLM, which queries and responds to the Recsys LLM to achieve the goal. The Recsys LLM
                    doesn't know the goal, but it knows the recommendation pool and recommends music each turn based on
                    the Listener LLM's messages.</p>

                <p>As a result, this is essentially an agentic pipeline, simulating real-world conversations between a
                    listener and a music recommender.</p>
            </div>

            <div class="text-center mb-4">
                <img src="./static/TalkPlayData_2.jpg" alt="TalkPlayData 2 Pipeline" class="img-fluid"
                    style="max-width: 100%; height: auto;">
                <p class="text-muted mt-2"><small>Pipeline for generating conversational music recommendation
                        data</small></p>
            </div>

            <div class="mb-4">
                <h3>Multimodal and Conversational, in one LLM.</h3>
                <p>In our pipeline, all the LLMs are multimodal - they can listen to the audio and see images, besides
                    understanding various sub-modalities in text such as lyrics and chords.</p>

                <p>Not to mention they're conversational - just like TalkPlay 1, that's why we're using LLMs as a
                    recommendation engine.</p>

                <p>This is nicely put along the line of bigger models, and less number of components -- extending the
                    scope of a single model (LLM). An important contrast to the existing systems which have different,
                    separate components to handle different modalities, connected non-differentially.</p>
            </div>

            <div class="mb-4">
                <h3>So, what can you do with TalkPlayData 2?</h3>
                <p>We have released the <a href="https://github.com/talkpl-ai/talkplaydata-2" target="_blank">code</a> -
                    you can inspect the generation process in detail.</p>

                <p>You can also use <a href="https://huggingface.co/datasets/talkpl-ai/TalkPlayData-2"
                        target="_blank">our dataset </a> train and evaluate your conversational music recommender.</p>

                <p>Since the data even includes the listener's evaluation on each recommendation, you can even finetune / apply RL to the recommender and optimize the recommendation performance.</p>

            </div>

            </div>
        </div>

            <style>
                /* Conversation demo styling (aligned with other project pages) */
                .demo-meta { margin-bottom: 1rem; padding: .75rem 1rem; background: #f8f9fa; border: 1px solid #e9ecef; border-radius: 6px; }
                .demo-meta h5 { margin: 0 0 .5rem 0; }
                .meta-block { background: #fff; border: 1px solid #e5e7eb; border-radius: 8px; padding: .75rem 1rem; margin-bottom: .75rem; }
                .meta-block h5 { margin: 0 0 .5rem 0; }
                .badges { display: flex; gap: .5rem; margin: .25rem 0 .5rem 0; }
                .badge { display: inline-block; padding: 2px 8px; border-radius: 999px; font-size: .75rem; border: 1px solid #e5e7eb; }
                .badge-on { background: #e8f0fe; color: #1e3a8a; border-color: #bfd3fe; }
                .badge-off { background: #f9fafb; color: #9ca3af; }
                .tracks-list { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: .35rem .75rem; }
                .tracks-list .item { font-size: .9rem; color: #374151; display: flex; align-items: center; gap: 6px; }
                .audio-inline { height: 28px; vertical-align: middle; margin-left: 8px; }
                /* Compact inline player */
                .mini-player { display: inline-flex; align-items: center; gap: 6px; margin-left: 4px; white-space: nowrap; padding: 1px 6px 1px 1px; border: 1px solid #e2e8f0; border-radius: 7px; background: #ffffff; }
                /* Inner R (6px) + padding-left (1px) â‰ˆ outer R (7px) */
                .mini-btn { width: 16px; height: 16px; flex: 0 0 16px; box-sizing: border-box; padding: 0; border-radius: 6px; border: none; background: #f1f5f9; color: #0f172a; display: inline-flex; align-items: center; justify-content: center; cursor: pointer; box-shadow: inset 0 0 0 1px #cbd5e1; -webkit-tap-highlight-color: transparent; transition: background .15s ease, box-shadow .15s ease; }
                .mini-btn:hover { background: #eaf0f6; box-shadow: inset 0 0 0 1px #94a3b8; }
                .mini-bar { width: 80px; height: 4px; background: #e5e7eb; border-radius: 999px; position: relative; overflow: hidden; }
                .mini-fill { position: absolute; top:0; left:0; height:100%; width:0%; background: #94a3b8; }
                .chat-container { max-width: 900px; margin: 0 auto; }
                .message-container { overflow: hidden; margin-bottom: 10px; }
                .message { padding: 10px 15px; border-radius: 14px; max-width: 75%; border: 1px solid #ddd; background: #f8f9fa; }
                .user-message { float: left; background: #fff; }
                .assistant-message { float: right; }
                .music-message { float: right; border-style: dashed; }
                .music-title { font-weight: 600; margin-bottom: 6px; }
                .section-divider { margin: 18px 0; }
                .pagination.justify-content-center { margin-bottom: 12px; }
                .chat-legend { max-width: 900px; margin: 0 auto 12px auto; display: flex; justify-content: space-between; }
                .chat-legend .label-left, .chat-legend .label-right { font-size: .85rem; color: #6b7280; }
            </style>

        <div class="container pt-5 shadow p-5 mb-5 bg-white rounded">
            <div class="mb-4">
                <h3 class="mb-2">Demo Conversations</h3>
                <p class="text-muted" style="margin-top: -6px;">Each example shows a short goal-oriented session. Goal and listener profile are summarized first; conversation follows.</p>
                <ul id="tpd2-pages" class="pagination justify-content-center"></ul>

                <div id="tpd2-meta" class="demo-meta"></div>
                <div class="chat-section">
                    <div class="chat-legend"><span class="label-left">Listener</span><span class="label-right">RecSys</span></div>
                    <div class="chat-container" id="tpd2-chat"></div>
                </div>

                <div class="text-end">
                    <a id="tpd2-raw-link" class="small" href="#" target="_blank" rel="noopener">View raw JSON</a>
                </div>
            </div>
        </div>
        </div>
    </div>

    <script>
        // Demo sessions (auto-listed)
        const AVAILABLE_SESSIONS = [
            { userId: '4006', date: '2019-02-15' },
            { userId: '5100', date: '2019-05-15' },
            { userId: '643', date: '2019-12-14' },
            { userId: '798', date: '2019-12-08' },
            { userId: '9142', date: '2019-05-06' },
            { userId: '9842', date: '2019-04-17' },
            { userId: '11132', date: '2019-09-08' }
        ];

        // ------- DEMO RENDERING (conversation-like view) -------
        async function fetchChat(session) {
                    const sessionPath = `./static/conversations/${session.userId}/${session.date}`;
            const res = await fetch(`${sessionPath}/chat.json`);
            if (!res.ok) throw new Error('chat.json not found');
            const json = await res.json();
            return { json, sessionPath };
        }

        // ------- Preview audio URL loader -------
        let previewMap;
        async function loadPreviewMap() {
            if (previewMap) return previewMap;
            // Use root-absolute path to be robust on GitHub Pages/custom domains
            let res = await fetch('/p/talkplaydata2/preview_urls.csv').catch(() => null);
            if (!res || !res.ok) {
                // Fallback to relative path if running locally without the /p/ prefix
                try { res = await fetch('./preview_urls.csv'); } catch (_) { /* noop */ }
            }
            if (!res.ok) { previewMap = new Map(); return previewMap; }
            const text = await res.text();
            previewMap = new Map();
            const rows = parseCSV(text);
            for (const cols of rows) {
                if (cols.length < 6) continue;
                const trackId = (cols[1] || '').trim();
                const url = (cols[5] || '').trim();
                if (trackId && url) previewMap.set(trackId, url);
            }
            return previewMap;
        }
        function getPreviewUrl(trackId) { return previewMap ? (previewMap.get(trackId) || null) : null; }
        function parseCSV(text) {
            const out = []; let row = []; let cur = ''; let inQuotes = false;
            for (let i = 0; i < text.length; i++) {
                const ch = text[i];
                if (inQuotes) {
                    if (ch === '"') { if (text[i + 1] === '"') { cur += '"'; i++; } else { inQuotes = false; } }
                    else { cur += ch; }
                } else {
                    if (ch === '"') inQuotes = true;
                    else if (ch === ',') { row.push(cur); cur = ''; }
                    else if (ch === '\n' || ch === '\r') { if (cur.length || row.length) { row.push(cur); out.push(row); row = []; cur = ''; } if (ch === '\r' && text[i + 1] === '\n') i++; }
                    else cur += ch;
                }
            }
            if (cur.length || row.length) { row.push(cur); out.push(row); }
            return out;
        }

        function renderMeta(json, sessionPath) {
            const metaEl = document.getElementById('tpd2-meta');
            const goal = json.conversation_goal || {};
            const profile = json.listener_profile || {};
            const listenerTracks = (json.session_context && Array.isArray(json.session_context.listener_tracks)) ? json.session_context.listener_tracks : [];
            const poolTracks = (json.session_context && Array.isArray(json.session_context.recommendation_pool_tracks)) ? json.session_context.recommendation_pool_tracks : [];
            const CATEGORY_DESCRIPTIONS = {
                'A': 'Simple Attribute Match',
                'B': 'Lyrical Discovery',
                'C': 'Mood & Activity',
                'D': 'Temporal/Era Focus',
                'E': 'Audio/Musical Features',
                'F': 'Topic/Theme',
                'G': 'Cultural & Geographic',
                'H': 'Artist & Discography Discovery',
                'I': 'Cultural & Geographic',
            };
            const SPECIFICITY_DESCRIPTIONS = {
                'HH': 'High query specificity, high target specificity',
                'HL': 'High query specificity, low target specificity',
                'LH': 'Low query specificity, high target specificity',
                'LL': 'Low query specificity, low target specificity',
            };
            const catCode = (goal.category || '').toUpperCase();
            const specCode = (goal.specificity || '').toUpperCase();
            const catDesc = CATEGORY_DESCRIPTIONS[catCode] || '-';
            const specDesc = SPECIFICITY_DESCRIPTIONS[specCode] || '-';
            function tracksPreview(items, opts) {
                const max = (opts && typeof opts.max === 'number') ? opts.max : 6;
                const withAudio = (opts && opts.withAudio) || 'none';
                const single = !!(opts && opts.singleColumn);
                const listHtml = (items || []).slice(0, max).map((t, idx) => {
                    const base = `${(t.title||'-')} â€” ${(t.artist||'')}`;
                    let audio = '';
                    if (withAudio === 'all' || (withAudio === 'first' && idx === 0)) {
                        const prev = getPreviewUrl(t.track_id);
                        if (prev) audio = ` <span class=\"mini-audio\" data-src=\"${prev}\"></span>`;
                    }
                    return `<div class=\"item\">${base}${audio}</div>`;
                }).join('');
                const more = (items || []).length > max ? `<div class=\"small text-muted\" style=\"margin-top:4px;\">+${items.length - max} more</div>` : '';
                const cls = single ? 'tracks-list single' : 'tracks-list';
                return `<div class=\"${cls}\">${listHtml}</div>${more}`;
            }

            metaEl.innerHTML = `
                <div class="meta-block">
                    <h5>Profiling Tracks</h5>
                    <div class="badges">
                        <span class="badge badge-on">Shared with Listener</span>
                        <span class="badge badge-off">Not with RecSys</span>
                                        </div>
                    ${tracksPreview(listenerTracks, { withAudio: 'all', max: 5, singleColumn: true })}
                                            </div>

                <div class="meta-block">
                    <h5>Conversation Goal</h5>
                    <div class="badges">
                        <span class="badge badge-on">Shared with Listener</span>
                        <span class="badge badge-off">Not with RecSys</span>
                                            </div>
                    <div class="small text-muted">Category</div>
                    <div><strong>${goal.category || '-'}</strong> Â· ${catDesc}</div>
                    <div class="small text-muted" style="margin-top:6px;">Specificity</div>
                    <div><strong>${goal.specificity || '-'}</strong> Â· ${specDesc}</div>
                    <div class="small text-muted" style="margin-top:6px;">Listener goal</div>
                    <div>${goal.listener_goal || '-'}</div>
                    <div class="small text-muted" style="margin-top:6px;">Target turn count</div>
                    <div>${goal.target_turn_count || '-'}</div>
                    <div class="small" style="margin-top:6px;">
                        <a href="${sessionPath}/conversation_goal.json" target="_blank" rel="noopener">goal JSON</a>
                                            </div>
                                        </div>

                <div class="meta-block">
                    <h5>Listener Profile</h5>
                    <div class="badges">
                        <span class="badge badge-on">Shared with Listener</span>
                        <span class="badge badge-on">Shared with RecSys</span>
                    </div>
                    <div class="small text-muted">Age group</div>
                    <div>${profile.age_group || '-'}</div>
                    <div class="small text-muted" style="margin-top:6px;">Country</div>
                    <div>${profile.country || '-'}</div>
                    <div class="small text-muted" style="margin-top:6px;">Gender</div>
                    <div>${profile.gender || '-'}</div>
                    <div class="small text-muted">Top genre</div>
                    <div>${profile.top_1_genre || '-'}</div>
                    <div class="small text-muted" style="margin-top:6px;">Preferred culture</div>
                    <div>${profile.preferred_musical_culture || '-'}</div>
                    <div class="small" style="margin-top:6px;">
                        <a href="${sessionPath}/profiling.json" target="_blank" rel="noopener">profile JSON</a>
                                    </div>
                                </div>

                <div class="meta-block">
                    <h5>Recommendation Pool</h5>
                    <div class="badges">
                        <span class="badge badge-off">Not shared with Listener</span>
                        <span class="badge badge-on">Shared with RecSys</span>
                    </div>
                    <details>
                        <summary>Show recommendation pool (${poolTracks.length})</summary>
                        ${tracksPreview(poolTracks, { withAudio: 'first', max: 12 })}
                    </details>
                </div>
            `;
            const rawLink = document.getElementById('tpd2-raw-link');
            if (rawLink) rawLink.href = `${sessionPath}/chat.json`;
            hydrateMiniPlayers(metaEl);
        }

        function roleBubble(role) {
            if (role === 'user') return 'message user-message';
            if (role === 'assistant') return 'message assistant-message';
            if (role === 'music') return 'message music-message';
            return 'message';
        }

        function renderConversation(json) {
            const container = document.getElementById('tpd2-chat');
            container.innerHTML = '';

            const turns = (json.conversation_turns || []);
            for (let i = 0; i < turns.length; i++) {
                const t = turns[i];
                // Listener message first, then RecSys recommendation
                if (t.listener_turn && t.listener_turn.message) {
                    const wrap = document.createElement('div');
                    wrap.className = 'message-container';
                    const msg = document.createElement('div');
                    msg.className = roleBubble('user');
                    msg.textContent = (t.listener_turn.message || '').toString();
                    wrap.appendChild(msg);
                    container.appendChild(wrap);
                }

                if (t.recsys_turn && t.recsys_turn.track) {
                    const track = t.recsys_turn.track;
                    const wrap = document.createElement('div');
                    wrap.className = 'message-container';
                    const msg = document.createElement('div');
                    msg.className = roleBubble('music');
                    const title = document.createElement('div');
                    title.className = 'music-title';
                    const baseTitle = `${track.title || 'Unknown'} â€” ${track.artist || ''}`;
                    const preview = getPreviewUrl(track.track_id);
                    title.innerHTML = preview ? `${baseTitle} <span class=\"mini-audio\" data-src=\"${preview}\"></span>` : baseTitle;
                    msg.appendChild(title);
                    const txt = document.createElement('div');
                    txt.textContent = (t.recsys_turn.message || '').toString();
                    msg.appendChild(txt);
                    wrap.appendChild(msg);
                    container.appendChild(wrap);
                }
            }
            hydrateMiniPlayers(container);
        }

        // Compact player hydration
        function hydrateMiniPlayers(root) {
            const ctx = root || document;
            ctx.querySelectorAll('.mini-audio').forEach(ph => {
                const src = ph.getAttribute('data-src');
                if (!src) return;
                const audio = new Audio(src);
                audio.preload = 'none';
                const btn = document.createElement('button');
                btn.className = 'mini-btn';
                btn.textContent = 'â–¶';
                const bar = document.createElement('div');
                bar.className = 'mini-bar';
                const fill = document.createElement('div');
                fill.className = 'mini-fill';
                bar.appendChild(fill);
                const wrap = document.createElement('span');
                wrap.className = 'mini-player';
                wrap.appendChild(btn);
                wrap.appendChild(bar);
                let playing = false;
                btn.addEventListener('click', () => {
                    if (!playing) {
                        document.querySelectorAll('.mini-player').forEach(w => { if (w !== wrap) w.dispatchEvent(new CustomEvent('mini-stop')); });
                        audio.play();
                    } else {
                        audio.pause();
                    }
                });
                wrap.addEventListener('mini-stop', () => { if (!audio.paused) audio.pause(); });
                audio.addEventListener('play', () => { playing = true; btn.textContent = 'â¸'; });
                audio.addEventListener('pause', () => { playing = false; btn.textContent = 'â–¶'; });
                audio.addEventListener('timeupdate', () => { const p = audio.duration ? Math.min(1, audio.currentTime / audio.duration) : 0; fill.style.width = `${p * 100}%`; });
                audio.addEventListener('ended', () => { playing = false; btn.textContent = 'â–¶'; fill.style.width = '0%'; });
                ph.replaceWith(wrap);
            });
        }

        // (intentionally no message normalization; render exactly as provided)

        async function loadDemo(index) {
            const s = AVAILABLE_SESSIONS[index];
            const { json, sessionPath } = await fetchChat(s);
            renderMeta(json, sessionPath);
            renderConversation(json);
        }

        // Function to load and display JSON files
        async function loadJsonFile(filePath, fileName, userId, date) {
            try {
                const response = await fetch(filePath);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const jsonData = await response.json();

                // Hide sessions list and show JSON viewer
                document.getElementById('sessions-container').style.display = 'none';
                document.getElementById('json-viewer').style.display = 'block';

                // Update URL
                history.pushState(null, '', `talkplaydata2.html?user=${userId}&date=${date}&file=${fileName}`);

                // Display the JSON
                document.getElementById('current-file-name').textContent = `${userId}/${date}/${fileName}`;
                displayCollapsibleJson(jsonData);

            } catch (error) {
                console.error('Error loading JSON file:', error);
                alert('Error loading JSON file. Please try again.');
            }
        }

        // Function to display JSON with collapsible sections
        function displayCollapsibleJson(data) {
            const jsonContent = document.getElementById('json-content');
            const jsonInfo = document.getElementById('json-info');

            // Count total items for info display
            const totalItems = countJsonItems(data);
            jsonInfo.textContent = `${totalItems} items`;

            // Create collapsible HTML
            const html = createCollapsibleHtml(data, 'root');
            jsonContent.innerHTML = html;

            // Add click handlers
            addCollapsibleHandlers();
        }

        // Function to count JSON items
        function countJsonItems(obj) {
            if (Array.isArray(obj)) {
                return obj.length;
            } else if (typeof obj === 'object' && obj !== null) {
                return Object.keys(obj).length;
            }
            return 1;
        }

        // Function to create collapsible HTML
        function createCollapsibleHtml(data, path) {
            if (Array.isArray(data)) {
                return createArrayHtml(data, path);
            } else if (typeof data === 'object' && data !== null) {
                return createObjectHtml(data, path);
            } else {
                return `<span class="json-value">${JSON.stringify(data)}</span>`;
            }
        }

        // Function to create HTML for arrays
        function createArrayHtml(arr, path) {
            if (arr.length === 0) {
                return '<span class="json-value">[]</span>';
            }

            let html = '<span class="collapsible" data-path="' + path + '">';
            html += '<span class="toggle-icon">â–¶</span>';
            html += '<span class="json-value">[</span>';
            html += '<span class="json-info">' + arr.length + ' items</span>';
            html += '</span>';

            html += '<div class="collapsible-content" data-path="' + path + '">';
            arr.forEach((item, index) => {
                html += '<div>';
                html += createCollapsibleHtml(item, path + '[' + index + ']');
                if (index < arr.length - 1) html += ',';
                html += '</div>';
            });
            html += '</div>';
            html += '<span class="json-value">]</span>';

            return html;
        }

        // Function to create HTML for objects
        function createObjectHtml(obj, path) {
            const keys = Object.keys(obj);
            if (keys.length === 0) {
                return '<span class="json-value">{}</span>';
            }

            let html = '<span class="collapsible" data-path="' + path + '">';
            html += '<span class="toggle-icon">â–¶</span>';
            html += '<span class="json-value">{</span>';
            html += '<span class="json-info">' + keys.length + ' properties</span>';
            html += '</span>';

            html += '<div class="collapsible-content" data-path="' + path + '">';
            keys.forEach((key, index) => {
                html += '<div>';
                html += '<span class="json-key">"' + key + '": </span>';
                html += createCollapsibleHtml(obj[key], path + '.' + key);
                if (index < keys.length - 1) html += ',';
                html += '</div>';
            });
            html += '</div>';
            html += '<span class="json-value">}</span>';

            return html;
        }

        // Function to add click handlers for collapsible elements
        function addCollapsibleHandlers() {
            document.querySelectorAll('.collapsible').forEach(element => {
                element.addEventListener('click', function (e) {
                    e.stopPropagation();
                    const path = this.getAttribute('data-path');
                    const content = document.querySelector('.collapsible-content[data-path="' + path + '"]');
                    const icon = this.querySelector('.toggle-icon');

                    if (content.classList.contains('expanded')) {
                        content.classList.remove('expanded');
                        icon.textContent = 'â–¶';
                    } else {
                        content.classList.add('expanded');
                        icon.textContent = 'â–¼';
                    }
                });
            });
        }

        // Function to toggle all JSON sections
        function toggleAllJson() {
            const btn = document.getElementById('toggle-all-btn');
            const contents = document.querySelectorAll('.collapsible-content');
            const icons = document.querySelectorAll('.toggle-icon');

            if (btn.textContent === 'Expand All') {
                contents.forEach(content => content.classList.add('expanded'));
                icons.forEach(icon => icon.textContent = 'â–¼');
                btn.textContent = 'Collapse All';
                btn.classList.add('active');
            } else {
                contents.forEach(content => content.classList.remove('expanded'));
                icons.forEach(icon => icon.textContent = 'â–¶');
                btn.textContent = 'Expand All';
                btn.classList.remove('active');
            }
        }



        // Function to show the sessions list
        function showSessionsList() {
            document.getElementById('sessions-container').style.display = 'block';
            document.getElementById('json-viewer').style.display = 'none';
            history.pushState(null, '', 'talkplaydata2.html');
        }

        // Init demo and pagination
        document.addEventListener('DOMContentLoaded', () => {
            // build pagination dynamically
            const pages = document.getElementById('tpd2-pages');
            pages.innerHTML = AVAILABLE_SESSIONS.map((_, i) => `<li class=\"page-item${i===0?' active':''}\"><a class=\"page-link\" href=\"#\" data-demo=\"${i}\">${i+1}</a></li>`).join('');
            pages.querySelectorAll('.page-link').forEach(a => {
                a.addEventListener('click', async (e) => {
                    e.preventDefault();
                    const idx = parseInt(a.getAttribute('data-demo'), 10) || 0;
                    pages.querySelectorAll('.page-item').forEach(li => li.classList.remove('active'));
                    a.parentElement.classList.add('active');
                    try {
                        await loadPreviewMap();
                        await loadDemo(idx);
                    } catch (err) {
                        document.getElementById('tpd2-chat').innerHTML = `<div class=\"loading\">Failed to load demo.</div>`;
                        console.error(err);
                    }
                });
            });

            loadPreviewMap().then(() => loadDemo(0)).catch(err => {
                document.getElementById('tpd2-chat').innerHTML = `<div class="loading">Failed to load demo.</div>`;
                console.error(err);
            });
        });
    </script>
</body>

</html>
