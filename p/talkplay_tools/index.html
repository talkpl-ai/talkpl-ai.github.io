<!DOCTYPE html>
<html lang="en">

<head>
  <title>TalkPlay: Multimodal Music Recommendation with Large Language Models</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" />
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script src="helper-v2.js" defer></script>
  <link rel="stylesheet" href="style.css">
  <style>
    /* Update navigation styles to be thinner */
    .nav-bar {
      background-color: white;
      padding: 0.5rem 1rem;
      /* Reduced from 1rem */
      position: fixed;
      top: 0;
      width: 100%;
      z-index: 1000;
      border-bottom: 1px solid #eee;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.02);
    }

    .nav-bar a {
      color: #444;
      /* Changed from #333 to slightly lighter */
      text-decoration: none;
      padding: 0.3rem 0.8rem;
      margin: 0 0.3rem;
      border-radius: 4px;
      transition: all 0.2s ease;
      font-size: 0.95rem;
    }

    .nav-bar a:hover {
      background-color: #f5f5f5;
      color: #000;
    }

    .nav-bar a.active {
      background-color: #f5f5f5;
      color: #000;
    }

    /* Update content margin to match thinner navbar */
    .content {
      margin-top: 50px;
      /* Reduced from 70px */
      padding: 20px;
    }

    /* Minimal chat styling */
    .chat-msg {
      border-radius: 8px;
      padding: 10px 12px;
      margin: 6px 0;
      border: 1px solid #eee;
      background: #fafafa;
    }

    .chat-role {
      font-size: 0.85rem;
      font-weight: 600;
      color: #666;
      margin-bottom: 4px;
    }

    .role-user {
      color: #0d6efd;
    }

    .role-assistant {
      color: #198754;
    }

    .role-music {
      color: #198754;
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.9rem;
      word-break: break-all;
    }

    .kv dt {
      font-weight: 600;
      color: #555;
    }

    .kv dd {
      margin-bottom: .5rem;
    }

    /* Conversation UI borrowed from projects/talkplay/style.css */
    .chat-container {
      max-width: 800px;
      margin: 0px auto;
      font-family: Arial, sans-serif;
      background-color: white;
      border-radius: 8px;
    }

    .message {
      padding: 10px 15px;
      border-radius: 15px;
      max-width: 70%;
      clear: both;
      background-color: #f8f9fa;
      border: 1px solid #ddd;
    }

    .user-message {
      float: left;
      background-color: white;
    }

    .assistant-message {
      float: right;
    }

    .music-message {
      float: right;
      font-family: monospace;
    }

    .message-container {
      overflow: hidden;
      margin-bottom: 10px;
    }

    .chat-section {
      margin: 40px 0;
      padding: 20px;
      border: 1px solid #ddd;
      border-radius: 8px;
    }

    .message-container:nth-last-of-type(1) .music-message,
    .message-container:nth-last-of-type(2) .assistant-message {
      background-color: #e8f5e9;
      border: 1px solid #c8e6c9;
    }

    /* Role-based alignment and bubble colors */
    .chat-msg {
      max-width: 75%;
    }

    .chat-msg.align-right {
      margin-left: auto;
    }

    .chat-msg.is-user {
      background: #f8f9fa;
      border-color: #e9ecef;
    }

    .chat-msg.is-assistant {
      background: #f8f9fa;
      border-color: #dbdcdd;
    }

    .chat-msg.is-music {
      background: #f8f9fa;
      border-color: #dbdcdd;
    }
  </style>
</head>

<body>
  <div class="content">
    <div class="container pt-5 mt-5 shadow p-5 mb-5 bg-white rounded">
      <div class="text-center">
        <h1 class="title is-1 publication-title">TalkPlay-Tools: <br /> Conversational Music Recommendation with LLM
          Tool
          Calling</h1>

        <div class="is-size-5 publication-authors">
          <span class="author-block">Seungheon Doh<sup>*,1,2</sup>, Keunwoo Choi<sup>*,2</sup>, Juhan
            Nam<sup>1</sup></span>
        </div>

        <div class="is-size-5 publication-authors">
          <span class="author-block" style="font-size: 1em">
            KAIST<sup>1</sup>, talkpl.ai<sup>2</sup>
          </span>
          <br>
          <span class="author-block" style="font-size: 0.8em; color: gray">
            * Equal contribution
          </span>
        </div>

        <div class="column has-text-centered">
          <div class="publication-links">
            <br>
            <b><a href="#" target="_blank">ArXiv (update soon)</a> | <a
                href="https://huggingface.co/datasets/talkpl-ai/TalkPlayData-2" target="_blank">Dataset</a> | <a
                href="https://github.com/talkpl-ai/talkplay-tools" target="_blank">Github</a></b>
          </div>
        </div>
      </div>
    </div>

    <div class="container pt-5 mt-5 shadow p-5 mb-5 bg-white rounded">
      <h3>Abstract</h3>
      <div class="container pt-3">
        <div class="content has-text-justified">
          <p>
            We propose an LLM-based music recommendation system with tool calling to serve as a unified
            retrieval-ranking pipeline. While recent developments in large language models (LLMs) have successfully
            enabled generative recommenders with natural language interactions, their recommendation behavior is
            limited, leaving other simpler yet crucial components such as metadata or attribute filtering underutilized
            in the system. Our system positions an LLM as an end-to-end recommendation system that interprets user
            intent, plans tool invocations, and orchestrates special- ized components—boolean filters (SQL), sparse
            retrieval (BM25), dense retrieval (embedding similarity), and generative retrieval (semantic IDs). Through
            tool plan- ning, the LLM predicts the 1) type of tools, 2) order of tools, and 3) arguments of tools – to
            find music for matching user preferences, supporting diverse modalities while seamlessly integrating
            multiple database filtering methods. We demonstrate that this unified tool-calling framework achieves
            competitive performance across diverse recommendation scenarios by selectively employing appropriate
            retrieval methods based on user queries, envisioning a new paradigm for conversational music recommendation
            systems.
          </p>
          <div class="row justify-content-center">
            <div class="col-12">
              <img src="./static/fig/main.png" class="img-fluid" alt="TalkPlay system overview"
                style="width: 80%; display: block; margin: 0 auto;">
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Render Conversation In here -->
    <div class="container pt-5 mt-5 shadow p-5 mb-5 bg-white rounded">
      <h3 class="mb-3">Demo Examples</h3>
      <div class="row g-3 align-items-end">
        <div class="col-md-6">
          <label for="sessionSelect" class="form-label">Select session</label>
          <select id="sessionSelect" class="form-select"></select>
        </div>
        <div class="col-md-6">
          <div id="sessionMeta" class="small text-muted"></div>
        </div>
      </div>

      <hr class="my-4" />

      <div class="row g-4">
        <div class="col-12">
          <h4 class="mb-2">Input: Chat History</h4>
          <div id="chatHistory"></div>
          <!-- <hr class="my-4" />
          <h6 class="mb-2 text-muted">Tools</h6> -->
          <!-- <div id="predTools" class="mono small"></div> -->
        </div>
      </div>

      <div id="loadError" class="alert alert-danger d-none mt-4" role="alert"></div>
    </div>

    <script>
      (function () {
        const JSON_BASE = './static/json/';
        const FILES = [
          '24392__2020-02-14.json',
          '24852__2020-02-27.json',
          '63883__2020-02-09.json',
          '24392__2019-12-11.json',
          '10907__2019-05-28.json'
        ];

        const els = {
          select: document.getElementById('sessionSelect'),
          meta: document.getElementById('sessionMeta'),
          chat: document.getElementById('chatHistory'),
          predTools: document.getElementById('predTools'),
          error: document.getElementById('loadError')
        };

        /** @type {Record<string, any>} */
        const sessions = {};

        function roleClass(role) {
          if (role === 'user') return 'role-user';
          if (role === 'assistant') return 'role-assistant';
          if (role === 'music') return 'role-music';
          return '';
        }

        function renderSession(sessionId) {
          const data = sessions[sessionId];
          if (!data) return;

          // meta
          els.meta.textContent = `session_id: ${data.session_id}  |  uid: ${data.uid}  |  turn_idx: ${data.turn_idx}`;

          // chat
          els.chat.innerHTML = '';
          // metadata block before first user query
          if (data.metadata && typeof data.metadata === 'object') {
            const metaWrap = document.createElement('div');
            metaWrap.className = 'chat-msg is-user';
            const role = document.createElement('div');
            role.className = 'chat-role role-user';
            role.textContent = 'profile';
            const content = document.createElement('div');
            content.className = 'mono small';
            Object.entries(data.metadata).forEach(([k, v]) => {
              const line = document.createElement('div');
              line.textContent = `${k}: ${v}`;
              content.appendChild(line);
            });
            metaWrap.appendChild(role);
            metaWrap.appendChild(content);
            els.chat.appendChild(metaWrap);
          }
          (data.chat_history || []).forEach(turn => {
            const div = document.createElement('div');
            const alignRight = (turn.role === 'assistant' || turn.role === 'music') ? ' align-right' : '';
            const roleClassName = turn.role === 'user' ? ' is-user' : (turn.role === 'assistant' ? ' is-assistant' : (turn.role === 'music' ? ' is-music' : ''));
            div.className = 'chat-msg' + alignRight + roleClassName;
            const role = document.createElement('div');
            role.className = 'chat-role ' + roleClass(turn.role);
            const roleText = turn.role === 'user' ? 'user' : (turn.role === 'assistant' ? 'assistant (response)' : (turn.role === 'music' ? 'assistant (music)' : turn.role));
            role.textContent = roleText;
            const content = document.createElement('div');
            if (turn.role === 'music' && turn.content && typeof turn.content === 'object') {
              const mc = turn.content;
              const block = document.createElement('div');
              block.className = 'music-block';

              if (mc.image_path) {
                const img = document.createElement('img');
                img.className = 'music-thumb';
                img.src = mc.image_path;
                img.alt = mc.title || 'album cover';
                block.appendChild(img);
              }

              const meta = document.createElement('div');
              meta.className = 'music-meta';

              const title = document.createElement('div');
              title.className = 'music-title';
              title.innerHTML = `${mc.title || ''} - ${mc.artist || ''} <span class="text-small-gray">(${mc.track_id || ''})</span>`;
              meta.appendChild(title);

              if (Array.isArray(mc.tag_list) && mc.tag_list.length) {
                const tagsDiv = document.createElement('div');
                tagsDiv.className = 'tag-list';
                const filtered = mc.tag_list.filter(t => typeof t === 'string' && t.length <= 20);
                const tags = filtered.slice(0, 5);
                tagsDiv.innerHTML = tags.map(t => `<span class="tag">${t}</span>`).join(' ');
                if (filtered.length > 5) {
                  const more = document.createElement('span');
                  more.className = 'tag more-tag';
                  more.textContent = `+${filtered.length - 5} more`;
                  tagsDiv.appendChild(more);
                }
                meta.appendChild(tagsDiv);
              }

              if (mc.audio_path) {
                const audio = document.createElement('audio');
                audio.controls = true;
                audio.src = mc.audio_path;
                audio.controlsList = 'nodownload noplaybackrate';
                audio.addEventListener('keydown', e => e.preventDefault());
                meta.appendChild(audio);
              }

              block.appendChild(meta);
              content.appendChild(block);
            } else {
              content.textContent = turn.content;
            }
            div.appendChild(role);
            div.appendChild(content);
            els.chat.appendChild(div);
          });

          // divider before prediction part
          els.chat.appendChild(document.createElement('br'));

          // tools as a chat bubble before music prediction
          if ((data.predict_tools || []).length) {
            const hr = document.createElement('hr');
            els.chat.appendChild(hr);
            const predictionHeader = document.createElement('h4');
            predictionHeader.textContent = 'Output: LLM Prediction';
            els.chat.appendChild(predictionHeader);
            if (data.predict_tool_cot) {
              const full = (data.predict_tool_cot || '').toString();
              const preview = full.replace(/\n+/g, ' ').slice(0, 100) + (full.length > 100 ? '…' : '');
              const details = document.createElement('details');
              details.className = 'cot-small';
              const summary = document.createElement('summary');
              summary.textContent = `<preview>${preview}</preview>`;
              const fullDiv = document.createElement('div');
              fullDiv.textContent = full;
              fullDiv.style.whiteSpace = 'pre-wrap';
              details.appendChild(summary);
              details.appendChild(fullDiv);

              const wrapper = document.createElement('div');
              wrapper.className = 'chat-msg align-right is-cot';
              const role = document.createElement('div');
              role.className = 'chat-role role-cot';
              role.textContent = 'chain-of-thought (tools)';
              wrapper.appendChild(role);
              wrapper.appendChild(details);
              els.chat.appendChild(wrapper);
            }
            const div = document.createElement('div');
            div.className = 'chat-msg align-right is-assistant';
            const role = document.createElement('div');
            role.className = 'chat-role role-assistant';
            role.textContent = 'assistant (tools)';
            const content = document.createElement('div');
            content.className = 'mono small';
            (data.predict_tools || []).forEach((t, i) => {
              const p = document.createElement('div');
              p.textContent = `${JSON.stringify(t)}`;
              content.appendChild(p);
            });
            div.appendChild(role);
            div.appendChild(content);
            els.chat.appendChild(div);
          }

          // append prediction as next turns (music first, then response)
          if (data.predict_music) {
            const div = document.createElement('div');
            div.className = 'chat-msg align-right is-music';
            const role = document.createElement('div');
            role.className = 'chat-role ' + roleClass('music');
            role.textContent = 'assistant (music)';
            const content = document.createElement('div');
            const mc = data.predict_music;
            if (mc && typeof mc === 'object') {
              const block = document.createElement('div');
              block.className = 'music-block';

              if (mc.image_path) {
                const img = document.createElement('img');
                img.className = 'music-thumb';
                img.src = mc.image_path;
                img.alt = mc.title || 'album cover';
                block.appendChild(img);
              }

              const meta = document.createElement('div');
              meta.className = 'music-meta';

              const title = document.createElement('div');
              title.className = 'music-title';
              title.innerHTML = `${mc.title || ''} - ${mc.artist || ''} <span class=\"text-small-gray\">(${mc.track_id || ''})</span>`;
              meta.appendChild(title);

              if (Array.isArray(mc.tag_list) && mc.tag_list.length) {
                const tagsDiv = document.createElement('div');
                tagsDiv.className = 'tag-list';
                const filtered = mc.tag_list.filter(t => typeof t === 'string' && t.length <= 20);
                const tags = filtered.slice(0, 5);
                tagsDiv.innerHTML = tags.map(t => `<span class=\"tag\">${t}</span>`).join(' ');
                if (filtered.length > 5) {
                  const more = document.createElement('span');
                  more.className = 'tag more-tag';
                  more.textContent = `+${filtered.length - 5} more`;
                  tagsDiv.appendChild(more);
                }
                meta.appendChild(tagsDiv);
              }

              if (mc.audio_path) {
                const audio = document.createElement('audio');
                audio.controls = true;
                audio.src = mc.audio_path;
                audio.controlsList = 'nodownload noplaybackrate';
                audio.addEventListener('keydown', e => e.preventDefault());
                meta.appendChild(audio);
              }

              block.appendChild(meta);
              content.appendChild(block);
            } else {
              content.className = 'mono';
              content.textContent = String(mc);
            }
            div.appendChild(role);
            div.appendChild(content);
            els.chat.appendChild(div);
          }

          if (data.predict_response) {
            if (data.predict_response_cot) {
              const full = (data.predict_response_cot || '').toString();
              const preview = full.replace(/\n+/g, ' ').slice(0, 100) + (full.length > 100 ? '…' : '');
              const details = document.createElement('details');
              details.className = 'cot-small';
              const summary = document.createElement('summary');
              summary.textContent = `<preview>${preview}</preview>`;
              const fullDiv = document.createElement('div');
              fullDiv.textContent = full;
              fullDiv.style.whiteSpace = 'pre-wrap';
              details.appendChild(summary);
              details.appendChild(fullDiv);

              const wrapper = document.createElement('div');
              wrapper.className = 'chat-msg align-right is-cot';
              const role = document.createElement('div');
              role.className = 'chat-role role-cot';
              role.textContent = 'chain-of-thought (response)';
              wrapper.appendChild(role);
              wrapper.appendChild(details);
              els.chat.appendChild(wrapper);
            }
            const div = document.createElement('div');
            div.className = 'chat-msg align-right is-assistant';
            const role = document.createElement('div');
            role.className = 'chat-role ' + roleClass('assistant');
            role.textContent = 'assistant (response)';
            const content = document.createElement('div');
            content.textContent = data.predict_response;
            div.appendChild(role);
            div.appendChild(content);
            els.chat.appendChild(div);
          }
        }

        async function loadAll() {
          try {
            const results = await Promise.all(FILES.map(name => fetch(JSON_BASE + name).then(r => {
              if (!r.ok) throw new Error(`HTTP ${r.status}`);
              return r.json();
            }).then(j => ({ name, data: j }))));

            // populate selector
            els.select.innerHTML = '';
            results.forEach(({ name, data }) => {
              sessions[data.session_id] = data;
              const opt = document.createElement('option');
              opt.value = data.session_id;
              opt.textContent = `${data.session_id} (uid ${data.uid})`;
              els.select.appendChild(opt);
            });

            if (els.select.options.length > 0) {
              renderSession(els.select.value = els.select.options[0].value);
            }

            els.select.addEventListener('change', () => renderSession(els.select.value));
          } catch (err) {
            els.error.classList.remove('d-none');
            els.error.textContent = `Failed to load conversations: ${err.message}`;
            console.error(err);
          }
        }

        loadAll();
      })();
    </script>
  </div>
</body>

</html>
